## Malware Techniques -- Code Snippets vs Assembly
The program that I took these code snippets from was my own creation. I wanted to practice identifying and bypassing various anti-analysis checks that I've seen in malware. The way that I designed the program to work is if any of the checks failed, it would return a 1 instead of a 0. If it returned 1, it would increment a total counter. If the result of the counter was anything other than a 0 by the end, the analyst has failed to bypass the checks and it would show the error message. I wanted to mention this in case any readers had any questions regarding the int function types and return values.

---

### Anti-Analyis

#### IsDebuggerPresent
```C++
int basicDebugger()
{
	BOOL basicDebugResult = IsDebuggerPresent();
	if (basicDebugResult == TRUE) {
		return 1;
	}
	return 0;
}
```
![IsDebuggerPresent](Pictures/IsDebuggerPresent.png)
---

#### Total RAM Amount
```C++
int ramCheck()
{
	MEMORYSTATUSEX statex;
	statex.dwLength = sizeof(statex);
	GlobalMemoryStatusEx(&statex);
	int ramResult = (float)statex.ullTotalPhys / (1024 * 1024 * 1024);
	if (ramResult < 6) {
		return 1;
	}
	return 0;
}
```

---

#### Total Processor Check
```C++
int procCheck()
{
	unsigned logicalCpuCount;
	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);
	logicalCpuCount = systemInfo.dwNumberOfProcessors;
	if (logicalCpuCount < 4) {
		return 1;
	}
	return 0;
}
```

---

#### Total Disk Size Check
```C++
int diskCheck()
{
	HANDLE hDevice = CreateFileW(L"\\\\.\\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	DISK_GEOMETRY pDiskGeometry;
	DWORD bytesReturned;
	DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &pDiskGeometry, sizeof(pDiskGeometry), &bytesReturned, (LPOVERLAPPED)NULL);
	DWORD diskSizeGB;
	diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;
	
	if (diskSizeGB < 250) {
		return 1;
	}

	return 0;
}
```

---

#### GetTickCount
```C++
int getTickCheck()
{
	unsigned int timestampOne = GetTickCount();
	OutputDebugString(L"Debug");
	unsigned int timestampTwo = GetTickCount();
	unsigned int difference = timestampTwo - timestampOne;
	if (difference > 1000) {
		return 1;
	}
	return 0;
}
```

---

#### CheckRemoteDebuggerPresent
```C++
int advancedDebug()
{
	BOOL isRemoteDebuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &isRemoteDebuggerPresent);

	if (isRemoteDebuggerPresent == TRUE) {
		return 1;
	}
	return 0;
}
```

---

#### VirtualBox Check
```C++
int vboxCheck()
{
	// Look for VirtualBox files
	WIN32_FIND_DATAW findFileData;
	if (FindFirstFileW(L"C:\\Windows\\System32\\VBox*.dll", &findFileData) != INVALID_HANDLE_VALUE) return 1;

	// Look for VirtualBox registry keys
	HKEY hkResult;
	if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\ControlSet001\\Services\\VBoxSF", 0, KEY_QUERY_VALUE, &hkResult) == ERROR_SUCCESS) return 1;

	return 0;
}
```

---

#### VMware Check
```C++
int vmWareCheck()
{
	// Look for VMware files
	WIN32_FIND_DATAW findFileData;
	if (FindFirstFileW(L"C:\\Windows\\System32\\drivers\\vmmouse.sys", &findFileData) != INVALID_HANDLE_VALUE) return 1;

	// Look for VMware registry keys
	HKEY hkResult;
	if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\VMware, Inc.\\VMware Tools", 0, KEY_QUERY_VALUE, &hkResult) == ERROR_SUCCESS) return 1;

	return 0;
}
```
